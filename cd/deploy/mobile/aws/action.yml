##
# (c) 2021-2025
#     Cloud Ops Works LLC - https://cloudops.works/
#     Find us on:
#       GitHub: https://github.com/cloudopsworks
#       WebSite: https://cloudops.works
#     Distributed Under Apache v2.0 License
#
name: Deploy Mobile Application AWS Device Farm
author: cloudopsworks
description: Deploy Mobile Application to AWS Device Farm
inputs:
  source_path:
    description: 'The path to the source code'
    required: false
    default: 'source'
  blueprint_path:
    description: 'The path to the blueprint'
    required: false
    default: 'bp'
  token:
    description: 'The GitHub token'
    required: true
  platform_type:
    description: 'The mobile platform type'
    required: true
  aws_region:
    description: 'The AWS region'
    required: true
  aws_sts_role_arn:
    description: 'The AWS STS Role ARN'
    required: true
  aws_access_key_id:
    description: 'The AWS access key ID'
    required: true
  aws_secret_access_key:
    description: 'The AWS secret access key'
    required: true
  terraform_state_conf:
    description: 'The Terraform state configuration'
    required: true
  unlock:
    description: 'Unlock the state'
    required: false
    default: 'false'
  lock_id:
    description: 'The lock ID'
    required: false
    default: ''
  destroy:
    description: 'Destroy the state'
    required: false
    default: 'false'
  release_name:
    description: 'The release name'
    required: true
  release_version:
    description: 'The release version'
    required: true
  qualifier:
    description: 'The release qualifier'
    required: false
    default: ''
  project_key:
    description: 'The package name'
    required: true
  deployment_name:
    description: 'The deployment name'
    required: true
  environment:
    description: 'The environment'
    required: true
  artifacts_name:
    description: 'The name of the artifacts to save'
    required: false
    default: 'build_artifacts'
  front_end:
    description: 'The front end flag, used mainly for NodeJS targets'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Device Farm Name
      id: device_farm
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        res=$(yq e '.aws.device_farm_name // ""' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Device Farm Pool
      id: device_pool
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        res=$(yq e '.aws.device_farm_pool // ""' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Test Script Path
      id: test_script_path
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        res=$(yq e '.aws.test_script_path // "device_tests"' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Tests Scripts Available
      id: test_script_available
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        res=false
        # Check dir exists
        if [ -d '${{ steps.test_script_path.outputs.result }}' ] ; then
          # Check dir has content
          if [ "$(ls -A '${{ steps.test_script_path.outputs.result }}')" ] ; then
            res=true
          fi
        fi
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Test Script Type
      id: test_script_type
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        res=$(yq e '.aws.test_script_type // "APPIUM_PYTHON_TEST_PACKAGE"' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Test Script Type for Schedule Run
      id: run_test_type
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        val=${{ steps.test_script_type.outputs.result }}
        # strip following from res string: _TEST_SPEC, _TEST_PACKAGE
        res=${val/_TEST_SPEC/}
        res=${res/_TEST_PACKAGE/}
        echo "result=$res" >> $GITHUB_OUTPUT

    - name: Generate release.yaml
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws
      shell: bash
      run: |
        cat > release.yaml << EOF 
        release:
          name: ${{ inputs.release_name }}
          source:
            name: ${{ inputs.project_key }}
            version: ${{ inputs.release_version }}${{ inputs.front_end == 'true' && format('-{0}', inputs.environment) || '' }}
        EOF

    - name: Insert release.qualifier data into release.yaml
      if: ${{ inputs.qualifier != '' }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws
      shell: bash
      run: yq e -i '.release.qualifier = "${{ inputs.qualifier }}"' release.yaml

    - name: Generate Global Inputs global-inputs.yaml
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws
      shell: bash
      run: |
        cat > global-inputs.yaml << EOF
        environment: ${{ inputs.deployment_name }}${{ inputs.qualifier != '' && '/' || '' }}${{ inputs.qualifier }}
        release_name: ${{ inputs.release_name }}
        default:
          region: ${{ inputs.aws_region }}
          sts_role_arn: ${{ inputs.aws_sts_role_arn }}
        EOF

    - name: Determine Plan Action
      uses: actions/github-script@v8
      id: plan_action
      with:
        script: |
          const is_destroy = ${{ inputs.destroy }};
          const is_unlock = ${{ inputs.unlock }};
          if (is_destroy) {
            core.setOutput('value', 'plan -destroy -no-color -input=false')
            console.log('destroy');
          } else {
            if (is_unlock) {
              core.setOutput('value', 'force-unlock -force ${{ inputs.lock_id }}')
              console.log('unlock');
            } else {
              core.setOutput('value', 'plan -no-color -input=false')
              console.log('apply');
            }
          }

    #
    # Login AWS
    - name: Configure AWS Credentials
      if: ${{ inputs.aws_sts_role_arn == '' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ inputs.aws_access_key_id }}
        aws-secret-access-key: ${{ inputs.aws_secret_access_key }}
        aws-region: ${{ inputs.aws_region }}

    #
    # Login AWS - w/Assume Role
    - name: Configure AWS Credentials with Assume Role
      if: ${{ inputs.aws_sts_role_arn != '' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ inputs.aws_access_key_id }}
        aws-secret-access-key: ${{ inputs.aws_secret_access_key }}
        role-to-assume: ${{ inputs.aws_sts_role_arn }}
        role-session-name: ${{ github.repository_id }}-build
        aws-region: ${{ inputs.aws_region }}

    - name: Device Farm ARN
      id: device_farm_arn
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws
      shell: bash
      run: |
        res=$(aws devicefarm list-projects \
          --region ${{ inputs.aws_region }} \
          --query "projects[?name=='${{ steps.device_farm.outputs.result }}'].arn | [0]" \
          --output text)
        echo "result=$res" >> $GITHUB_OUTPUT 

    - name: Device Pool ARN
      id: device_pool_arn
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws
      if: ${{ steps.device_pool.outputs.result != '' }}
      shell: bash
      run: |
        res=$(aws devicefarm list-device-pools \
          --region ${{ inputs.aws_region }} \
          --arn ${{ steps.device_farm_arn.outputs.result }} \
          --query "devicePools[?name=='${{ steps.device_pool.outputs.result }}'].arn | [0]" \
          --output text)
        echo "result=$res" >> $GITHUB_OUTPUT 

    - name: Restore Pipeline Artifacts
      uses: actions/download-artifact@v7
      if: ${{ inputs.artifacts_name != '' && inputs.unlock != 'true' && inputs.destroy != 'true' }}
      with:
        name: ${{ inputs.artifacts_name }}
        path: ${{ inputs.blueprint_path }}/devicefarms/aws/release

    - name: Restore Target BuildPipeline Artifacts
      uses: actions/download-artifact@v7
      if: ${{ inputs.artifacts_name != '' && inputs.unlock != 'true' && inputs.destroy != 'true' }}
      with:
        name: source_artifacts_target
        path: ${{ inputs.blueprint_path }}/devicefarms/aws/release

    - name: Untar extracted source_artifacts_target
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      run: |
        tar -xvf source_artifacts_target.tar
        rm -f source_artifacts_target.tar

    - name: Zip test contents - IOS
      if: ${{ steps.test_script_available.outputs.result == 'true' && contains(fromJSON('["ios"]'), inputs.platform_type) }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release/derived-data/Build/Products
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
      run: |
        tmpdir=$(mktemp -d)
        mkdir -p $tmpdir/.xctest
        if [[ "${{ steps.run_test_type.outputs.result }}" == "XCTEST_UI" ]]; then
          mv Debug-*/*Tests-Runner.app $tmpdir/ 
          mv *.xctestrun $tmpdir/
          cd $tmpdir/
          zip -r ${GITHUB_WORKSPACE}/${{ inputs.blueprint_path }}/devicefarms/aws/release/${REL}-${RELVER}${QUALI}-tests.zip .
        elif [[ "${{ steps.run_test_type.outputs.result }}" == "XCTEST" ]] ; then
          mv Debug-*/*.app/Plugins/*.xctest $tmpdir/
          cd $tmpdir/
          zip -r ${GITHUB_WORKSPACE}/${{ inputs.blueprint_path }}/devicefarms/aws/release/${REL}-${RELVER}${QUALI}-tests.zip .
        else
          echo "::warning::Unsupported test script type for iOS Device Farm XCTEST upload: ${{ steps.run_test_type.outputs.result }}"
        fi

    - name: Zip test contents - Android
      if: ${{ steps.test_script_available.outputs.result == 'true' && ! contains(fromJSON('["ios"]'), inputs.platform_type) }}
      working-directory: ${{ inputs.source_path }}/${{ steps.test_script_path.outputs.result }}
      shell: bash
      run: |
        zip -r ${GITHUB_WORKSPACE}/${{ inputs.blueprint_path }}/devicefarms/aws/release/${REL}-${RELVER}${QUALI}-tests.zip .

    - name: Rename IPA/APK
      id: ipa_apk
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
      run: |
        ext="${{ contains(fromJSON('["ios"]'), inputs.platform_type) && 'ipa' || 'apk' }}"
        app_type="${{ contains(fromJSON('["ios"]'), inputs.platform_type) && 'IOS_APP' || 'ANDROID_APP' }}"
        release=$(ls *.$ext 2>/dev/null)
        echo "Found: $release, moving to: ${REL}-${RELVER}${QUALI}.$ext" 
        mv "$release" ${REL}-${RELVER}${QUALI}.$ext
        echo "ext=$ext" >> $GITHUB_OUTPUT
        echo "app_type=$app_type" >> $GITHUB_OUTPUT

    - name: Upload IPA/APK
      id: upload_pkg
      if: ${{ ! cancelled() }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
        EXT: ${{ steps.ipa_apk.outputs.ext }}
        APP_TYPE: ${{ steps.ipa_apk.outputs.app_type }}
        GITHUB_API_TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::Upload IPA/APK to Device Farm"
        aws_result=$(aws devicefarm create-upload \
          --region ${{ inputs.aws_region }} \
          --project-arn ${{ steps.device_farm_arn.outputs.result }} \
          --name "${REL}-${RELVER}${QUALI}.$EXT" \
          --type "$APP_TYPE" \
          --content-type "application/octet-stream")
        arn=$(echo "$aws_result" | jq -r '.upload.arn')
        upload_url=$(echo "$aws_result" | jq -r '.upload.url')
        echo "ARN=$arn"
        curl -T "${REL}-${RELVER}${QUALI}.$EXT" -H "Content-Type: application/octet-stream" "$upload_url"
        # Retry 3 times with 10 sec - Get status wit aws devicefarm get-upload, depending on query upload.status if FAILED fail the step
        for i in {1..3}; do
          sleep 10
          status=$(aws devicefarm get-upload --arn $arn --query "upload.status" --output text)
          if [[ "$status" == "FAILED" ]]; then
            echo "::error::Upload failed, failing the step."
            exit 1
          elif [[ "$status" == "SUCCEEDED" ]]; then
            echo "Upload Succeeded!"
            break
          else
            echo "Upload status is $status, retrying"
          fi
        done
        echo "result=$arn" >> $GITHUB_OUTPUT
        echo "::endgroup::"

    - name: Deploy Test Package
      id: deploy_test_pkg
      if: ${{ steps.test_script_available.outputs.result == 'true' && ! cancelled() }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
        GITHUB_API_TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::Upload Test Package"
        aws_result=$(aws devicefarm create-upload \
          --region ${{ inputs.aws_region }} \
          --project-arn ${{ steps.device_farm_arn.outputs.result }} \
          --name "${REL}-${RELVER}${QUALI}-tests.zip" \
          --type "${{ steps.test_script_type.outputs.result }}" \
          --content-type "application/octet-stream")
        arn=$(echo "$aws_result" | jq -r '.upload.arn')
        upload_url=$(echo "$aws_result" | jq -r '.upload.url')
        echo "ARN=$arn"
        curl -T "${REL}-${RELVER}${QUALI}-tests.zip" -H "Content-Type: application/octet-stream" "$upload_url"
        # Retry 3 times with 10 sec - Get status wit aws devicefarm get-upload, depending on query upload.status if FAILED fail the step
        for i in {1..3}; do
          sleep 10
          status=$(aws devicefarm get-upload --arn $arn --query "upload.status" --output text)
          if [[ "$status" == "FAILED" ]]; then
            echo "::error::Upload failed, failing the step."
            exit 1
          elif [[ "$status" == "SUCCEEDED" ]]; then
            echo "Upload Succeeded!"
            break
          else
            echo "Upload status is $status, retrying"
          fi
        done
        echo "result=$arn" >> $GITHUB_OUTPUT
        echo "::endgroup::"

    - name: Schedule Run - Device Pool
      id: run_pool
      if: ${{ steps.test_script_available.outputs.result == 'true' && ! cancelled() && steps.deploy_test_pkg.outcome == 'success' && steps.upload_pkg.outcome == 'success' && steps.device_pool_arn.outputs.result != '' }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
      run: |
        echo "::group::Schedule Run - Device Pool"
        aws devicefarm schedule-run \
          --region ${{ inputs.aws_region }} \
          --project-arn ${{ steps.device_farm_arn.outputs.result }} \
          --app-arn ${{ steps.upload_pkg.outputs.result }} \
          --device-pool-arn ${{ steps.device_pool_arn.outputs.result }} \
          --name "${REL}-${RELVER}${QUALI}" \
          --test type=${{ steps.run_test_type.outputs.result }},testPackageArn=${{ steps.deploy_test_pkg.outputs.result }}
        echo "::endgroup::"

    - name: Retrieve Device Config Filter
      id: device_config_filter
      if: ${{ steps.device_pool_arn.outputs.result == '' }}
      working-directory: ${{ inputs.source_path }}
      shell: bash
      run: |
        ff=$(yq e '.aws.device.form_factor' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        model=$(yq e '.aws.device.model' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        osver=$(yq e '.aws.device.os_version' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        max=$(yq e '.aws.device.max_devices' .cloudopsworks/vars/inputs-${{ inputs.environment }}.yaml)
        plat="${{ contains(fromJSON('["ios"]'), inputs.platform_type) && 'iOS' || 'Android' }}"
        echo "filter={\"filters\":[{\"attribute\":\"PLATFORM\",\"operator\":\"EQUALS\",\"values\":[\"$plat\"]},{\"attribute\":\"FORM_FACTOR\",\"operator\":\"EQUALS\",\"values\":[\"$ff\"]},{\"attribute\":\"MODEL\",\"operator\":\"EQUALS\",\"values\":[\"$model\"]},{\"attribute\":\"OS_VERSION\",\"operator\":\"EQUALS\",\"values\":[\"$osver\"]}],\"maxDevices\":$max}" >> $GITHUB_OUTPUT

    - name: Schedule Run - Specific Devices
      id: run_device
      if: ${{ steps.test_script_available.outputs.result == 'true' && ! cancelled() && steps.deploy_test_pkg.outcome == 'success' && steps.upload_pkg.outcome == 'success' && steps.device_pool_arn.outputs.result == '' }}
      working-directory: ${{ inputs.blueprint_path }}/devicefarms/aws/release
      shell: bash
      env:
        REL: ${{ inputs.release_name }}
        RELVER: ${{ inputs.release_version }}
        QUALI: ${{ inputs.qualifier != '' && '-' || '' }}${{ inputs.qualifier }}
      run: |
        echo "::group::Schedule Run - Specific Devices"
        # Generate Filter Device - escape with \"
        aws devicefarm schedule-run \
          --region ${{ inputs.aws_region }} \
          --project-arn ${{ steps.device_farm_arn.outputs.result }} \
          --app-arn ${{ steps.upload_pkg.outputs.result }} \
          --device-selection-configuration '${{ steps.device_config_filter.outputs.filter }}' \
          --name "${REL}-${RELVER}${QUALI}" \
          --test type=${{ steps.run_test_type.outputs.result }},testPackageArn=${{ steps.deploy_test_pkg.outputs.result }}
        echo "::endgroup::"
